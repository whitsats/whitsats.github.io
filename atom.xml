<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://whitsats.github.io/</id>
    <title>W&apos;Blog</title>
    <updated>2025-06-21T15:21:45.928Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://whitsats.github.io/"/>
    <link rel="self" href="https://whitsats.github.io/atom.xml"/>
    <subtitle>兴趣是最好的老师</subtitle>
    <logo>https://whitsats.github.io/images/avatar.png</logo>
    <icon>https://whitsats.github.io/favicon.ico</icon>
    <rights>All rights reserved 2025, W&apos;Blog</rights>
    <entry>
        <title type="html"><![CDATA[我的“聪明”，正在毁掉我的生活]]></title>
        <id>https://whitsats.github.io/post/wo-de-cong-ming-zheng-zai-hui-diao-wo-de-sheng-huo/</id>
        <link href="https://whitsats.github.io/post/wo-de-cong-ming-zheng-zai-hui-diao-wo-de-sheng-huo/">
        </link>
        <updated>2025-06-21T15:16:23.000Z</updated>
        <summary type="html"><![CDATA[<p>我终于承认，我的“聪明”，正在毁掉我的生活。</p>
]]></summary>
        <content type="html"><![CDATA[<p>我终于承认，我的“聪明”，正在毁掉我的生活。</p>
<!-- more -->
<p>我一直觉得自己是个聪明人。脑子转得快，学什么都容易上手。但最近我不得不面对一个痛苦的事实：我的这份“聪明”，可能正在慢慢毁掉我的生活。</p>
<p>我有一种控制不住的表现欲，尤其是在我熟悉的人面前。脑子里只要冒出一点想法，哪怕它还不成形、不成熟，我都会迫不及待地抛出来，好像急于向世界证明我的思维有多活跃。</p>
<p>更糟糕的是，我偏执地渴望自己永远是“正确”的。我会因为一些毫无意义的小事和家人、同事争得面红耳赤。很多时候，争赢了又如何呢？除了换来对方的沉默和一段尴尬的关系，我什么也没得到。我也知道自己总在抱怨，明明工作一点没少做，事情也扛了下来，但从我嘴里说出来，就只剩下无尽的负能量。慢慢地，我发现没人愿意和我深入聊天了，家庭氛围也变得紧张。</p>
<p>我感到了前所未有的孤立和挫败。我引以为傲的头脑，在处理人际关系上，竟然如此无力。我意识到，不能再这样下去了。我必须亲自为我混乱的生活按下“修复”键。</p>
<p>我的自救之路：写给我自己的行动方案</p>
<p>这是一场自己与自己的战争，我为自己制定了几个作战计划：</p>
<p>第一，为我的大脑反应安装一个“暂停键”。<br>
冲动是魔鬼，我的冲动就是那“不假思索的快嘴”。我现在刻意训练自己，在想发表意见或反驳别人之前，先在心里停顿5秒。就是这短短的5秒，给了我一个缓冲，让我能判断一下：这话非说不可吗？说了会有什么后果？</p>
<p>第二，放弃“我是对的”，选择“我们是和谐的”。<br>
我开始告诉自己，在感情和合作中，“对错”是最低级的追求，“和谐”与“共赢”才是。当争论的念头再次升起时，我就在心里对自己喊“停”。我试着把“你不对，应该是……”换成“你说的有道理，同时我有个补充……”。当我不再咄咄逼人时，对方可能更能听进我的想法。</p>
<p>第三，用“感恩日记”替换“抱怨清单”。<br>
抱怨就像一个黑洞，会吸走所有的快乐。为了对抗这个坏习惯，我需要强迫自己每天睡前写下三件值得感恩的小事。我相信，一开始很难，但坚持下来后，我相信，我的关注点会从“我不满意的”转移到“我所拥有的”。心态变了，看世界的眼光也会变得柔和。</p>
<p>第四，少说多听，从“辩手”切换成“倾听者”。<br>
我过去总急于表达，把对话当成辩论赛。今后，我要努力扮演一个倾听者。把注意力放在理解对方的观点和情绪上，而不是忙着组织我的反驳语言。如果当我真正开始“听”，我觉得我不仅能学到更多，也能赢得更多真诚的交流。</p>
<p>这条路很难走，我依然会时常跌倒，变回那个固执、爱抱怨的自己。但没关系，我会把自己拉起来，拍拍尘土，然后继续前进。因为我知道，<strong>这是为了成为一个更值得被爱，也更懂得如何去爱的自己。</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[无奈]]></title>
        <id>https://whitsats.github.io/post/wu-nai/</id>
        <link href="https://whitsats.github.io/post/wu-nai/">
        </link>
        <updated>2025-05-26T13:43:31.000Z</updated>
        <summary type="html"><![CDATA[<p>今天的心情像天上的云，起起伏伏，最终还是被一股沉重的无奈笼罩。</p>
]]></summary>
        <content type="html"><![CDATA[<p>今天的心情像天上的云，起起伏伏，最终还是被一股沉重的无奈笼罩。</p>
<!-- more -->
<p>原定的北京之行，那是我期盼了多久的团聚啊。和媳妇约好了，要在金秋的帝都好好逛逛，感受一下久违的二人世界。然而，计划赶不上变化，或者说，赶不上专业的“老大难”问题。</p>
<p>卢院约谈了我，这是第几次来着？六次了！每一次都是围绕着那个去还是不去北京的问题。六次！我坐在那里，听着他为难的解释，看着他紧锁的眉头，心里真是五味杂陈。我知道他也不容易，专业课程体系的问题积重难返，急需人手来“救火”。而我，因为过去还算努力，还算能力够用，自然成了最合适的人选。</p>
<p>最终的结果，意料之中，却又让我心生疲惫。北京，去不成了。媳妇那边，只能带着歉意和遗憾去解释。</p>
<p>坐在办公室里，想着这六次的拉锯战，突然觉得好累。那种深深的无奈感，像是潮水一样把我淹没。我为自己因为工作牺牲个人时间而感到委屈，同时也为卢院的困境感到无奈——他需要人，但问题的根源在于更深层面的问题。</p>
<p>我在想，能力强的人，真的就活该多干活，多背那些别人的锅吗？“劣币驱逐良币”这句话，残酷却又精准地描述了现实。如果每个人都能守好自己的阵地，做好自己的本职工作，从最基本的备课、讲义、到课后反馈和出题，都保质保量地完成，专业体系又怎会落到今天这步田地？</p>
<p>可惜的是，现实并非如此。一些老师自身技术更新慢，课件敷衍了事，讲义不知所云，连最基础的备课都做得不到位。学生作业应付检查，考试题交给AI代劳……于是，一个专业，原本应该严谨有序的课程体系，就这样成了一团乱麻，而我们这些还想认真做事的，就被推到了风口浪尖，成了填补空缺的“救火队员”。</p>
<p>这种感觉，就像是在一片混乱的战场上，你拼命地去堵住漏洞，却发现漏洞源源不断，而那些本应一起并肩作战的战友，却在远处袖手旁观，甚至还在给你制造麻烦。</p>
<p>但，我还是会努力去做好的。毕竟，对得起自己的良心，才能对得起那些信任我们的学生。只是啊，这深夜里，这份无奈感，还是久久不能散去。什么时候，才能真正让能力和责任得到平等的对待呢？什么时候，才能让每个人都自觉地做好那份“本职”呢？</p>
<p>也许，这只是我心中的一个遥远的愿景吧。今夜，就让我在无奈中，带着一丝对明天的期盼，入睡吧。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue2 + Axios 使用讯飞大模型实现图文对话]]></title>
        <id>https://whitsats.github.io/post/vue2-axios-shi-yong-xun-fei-da-mo-xing-lite/</id>
        <link href="https://whitsats.github.io/post/vue2-axios-shi-yong-xun-fei-da-mo-xing-lite/">
        </link>
        <updated>2025-05-06T06:37:12.000Z</updated>
        <summary type="html"><![CDATA[<p>受同事老卢委托，近期我在一个 Vue2 项目中探索集成了 AI 对话功能。考虑到成本和便利性，讯飞星火大模型 Lite 版因其免费且不限次数的特性，成为了本次尝试的首选。下面我将详细记录整个集成过程，希望能为有类似需求的开发者提供一些参考。</p>
]]></summary>
        <content type="html"><![CDATA[<p>受同事老卢委托，近期我在一个 Vue2 项目中探索集成了 AI 对话功能。考虑到成本和便利性，讯飞星火大模型 Lite 版因其免费且不限次数的特性，成为了本次尝试的首选。下面我将详细记录整个集成过程，希望能为有类似需求的开发者提供一些参考。</p>
<!-- more -->
<h2 id="注册与配置讯飞星火大模型">注册与配置讯飞星火大模型</h2>
<p>首先，我们需要在讯飞开放平台注册并配置我们的应用。</p>
<p><strong>1. 注册账号与实名认证</strong><br>
访问讯飞开放平台并完成注册。注册过程相当简便直观。</p>
<figure data-type="image" tabindex="1"><img src="https://whitsats.github.io//post-images/1746513936583.png" alt="注册界面" width="400" loading="lazy"></figure>
<p>注册成功后，务必进行微信绑定和实名认证，这是使用后续服务的前提。</p>
<p><strong>2. 应用创建与配置</strong><br>
登录后，在控制台的“我的应用”界面，你会看到一个默认的应用。我们可以直接使用这个默认应用，或根据需要进行修改。</p>
<p><strong>3. 领取免费资源</strong><br>
进入应用，选择“模型服务与支持”中的 Spark Lite 版本，即可领取无限量的免费 token。</p>
<figure data-type="image" tabindex="2"><img src="https://whitsats.github.io//post-images/1746514880273.png" alt="领取token" width="600" loading="lazy"></figure>
<p>类似地，我们也可以领取一些免费的图片生成图点，用于体验图片生成功能。</p>
<figure data-type="image" tabindex="3"><img src="https://whitsats.github.io//post-images/1746543689686.png" alt="图点领取" width="600" loading="lazy"></figure>
<p>完成以上步骤后，记下应用的 <strong>APPID、APIKey、APISecret</strong> 以及对话接口的 <strong>APIPassword</strong>，这些凭证在后续调用 API 时至关重要。</p>
<h2 id="调试-api-参数">调试 API 参数</h2>
<p>为了确保顺利调用，我们可以先在讯飞提供的 API 调试中心进行测试。</p>
<p><strong>1. 文本对话 API (Spark Lite)</strong><br>
在星火调试中心，选择 Spark Lite 模型。既然是免费的，我们可以将各项参数（如 <code>max_tokens</code>、<code>temperature</code> 等）调整到合适的范围进行测试。</p>
<figure data-type="image" tabindex="4"><img src="https://whitsats.github.io//post-images/1746515114384.png" alt="模型参数" width="800" loading="lazy"></figure>
<p>调试中心主要演示的是流式对话的用例。如果我们需要非流式接口，可以查阅官方的参考文档。</p>
<figure data-type="image" tabindex="5"><img src="https://whitsats.github.io//post-images/1746515316767.png" alt="参考文档" width="400" loading="lazy"></figure>
<p>参考文档中提供了 Python 的非流式调用示例。我们可以参照其请求结构和参数，将其转换为在服务端使用 Axios 等库发送请求的形式。</p>
<figure data-type="image" tabindex="6"><img src="https://whitsats.github.io//post-images/1746515470897.png" alt="非流式用例" width="400" loading="lazy"></figure>
<p><strong>2. 图片生成 API</strong><br>
图片生成 API 的调用方式略有不同，它需要根据一定的规则生成签名 (Authorization)。</p>
<figure data-type="image" tabindex="7"><img src="https://whitsats.github.io//post-images/1746543834951.png" alt="图片签名" width="600" loading="lazy"></figure>
<p>官方文档指出，这两个 API（文本对话和图片生成）都不支持跨域请求，因此我们不能直接在前端调用，而是需要通过后端服务器进行代理。接下来，我们将使用 Koa2 搭建一个 Node.js 后端代理服务。</p>
<h2 id="搭建-koa2-代理服务器">搭建 Koa2 代理服务器</h2>
<p>为了解决跨域问题并安全地管理 API 密钥，我们将在服务端设置代理。</p>
<p><strong>1. 初始化项目与依赖</strong><br>
在你的项目下创建一个 <code>server</code> 文件夹，并初始化 <code>package.json</code>：</p>
<pre><code class="language-json">{
    &quot;name&quot;: &quot;sparkdemo-server&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;description&quot;: &quot;讯飞星火API代理服务器&quot;,
    &quot;main&quot;: &quot;app.js&quot;,
    &quot;scripts&quot;: {
        &quot;start&quot;: &quot;node app.js&quot;,
        &quot;dev&quot;: &quot;nodemon app.js&quot;
    },
    &quot;dependencies&quot;: {
        &quot;koa&quot;: &quot;^2.14.2&quot;,
        &quot;koa-bodyparser&quot;: &quot;^4.4.1&quot;,
        &quot;koa-router&quot;: &quot;^12.0.0&quot;,
        &quot;koa-cors&quot;: &quot;^0.0.16&quot;,
        &quot;axios&quot;: &quot;^1.5.0&quot;,
        &quot;crypto-js&quot;: &quot;^4.1.1&quot;
    },
    &quot;devDependencies&quot;: {
        &quot;nodemon&quot;: &quot;^3.0.1&quot;
    }
}
</code></pre>
<p>由于图片服务需要加密签名，我们引入了 <code>crypto-js</code>。运行 <code>npm install</code> 或 <code>yarn install</code> 安装依赖。</p>
<p><strong>2. 服务器基本配置 (<code>app.js</code>)</strong><br>
创建 <code>app.js</code> 文件，并配置基本的中间件和 API 信息：</p>
<pre><code class="language-javascript">const Koa = require(&quot;koa&quot;);
const Router = require(&quot;koa-router&quot;);
const bodyParser = require(&quot;koa-bodyparser&quot;);
const cors = require(&quot;koa-cors&quot;);
const axios = require(&quot;axios&quot;);
const CryptoJS = require(&quot;crypto-js&quot;);

// 创建Koa应用实例
const app = new Koa();
const router = new Router();

// 配置中间件
app.use(bodyParser()); // 解析请求体
app.use(cors()); // 启用CORS，允许跨域请求

// 服务器端口
const PORT = process.env.PORT || 3000;

// 讯飞星火API配置 (请替换为你的真实凭证)
const API_CONFIG = {
    APP_ID: &quot;YOUR_APP_ID&quot;,       // 你的 APPID
    API_KEY: &quot;YOUR_API_KEY&quot;,     // 你的 APIKey
    API_SECRET: &quot;YOUR_API_SECRET&quot;, // 你的 APISecret
    API_PASSWORD: &quot;YOUR_API_PASSWORD&quot;, // 对话接口的 APIPassword
    IMAGE_API_URL: &quot;https://spark-api.cn-huabei-1.xf-yun.com/v2.1/tti&quot;, // 图片生成接口
    CHAT_API_URL: &quot;https://spark-api.cn-huabei-1.xf-yun.com/v3.1/chat&quot;,   // v3.1 非流式对话接口
};
</code></pre>
<p><strong>注意：</strong> 请务必将 <code>API_CONFIG</code> 中的 <code>xxx</code> 替换为你自己应用的真实凭证。</p>
<p><strong>3. 图片生成 API 鉴权函数</strong><br>
根据讯飞官方文档的签名生成规则，我们编写一个函数来生成图片 API 所需的鉴权 URL：</p>
<pre><code class="language-javascript">/**
 * 生成图片API鉴权URL
 * @param {string} requestUrl - 原始请求URL
 * @param {string} method - 请求方法 (POST)
 * @param {string} apiKey - 应用的 APIKey
 * @param {string} apiSecret - 应用的 APISecret
 * @returns {string} - 带鉴权参数的URL
 */
function assembleAuthUrl(requestUrl, method = &quot;POST&quot;, apiKey, apiSecret) {
    const urlObj = new URL(requestUrl);
    const host = urlObj.host;
    const path = urlObj.pathname;
    const date = new Date().toUTCString();
    const signatureOrigin = `host: ${host}\ndate: ${date}\n${method} ${path} HTTP/1.1`;
    const signatureSha = CryptoJS.HmacSHA256(signatureOrigin, apiSecret);
    const signature = CryptoJS.enc.Base64.stringify(signatureSha);
    const authorizationOrigin = `api_key=&quot;${apiKey}&quot;, algorithm=&quot;hmac-sha256&quot;, headers=&quot;host date request-line&quot;, signature=&quot;${signature}&quot;`;
    const authorization = CryptoJS.enc.Base64.stringify(
        CryptoJS.enc.Utf8.parse(authorizationOrigin)
    );
    const params = new URLSearchParams();
    params.append(&quot;host&quot;, host);
    params.append(&quot;date&quot;, date);
    params.append(&quot;authorization&quot;, authorization);
    return `${requestUrl}?${params.toString()}`;
}
</code></pre>
<p><strong>4. 图片生成代理路由 (<code>/api/image-generation</code>)</strong><br>
接下来，配置图片生成的代理路由。此路由接收前端的请求，附加上述生成的鉴权信息，然后转发给讯飞的图片生成 API。</p>
<pre><code class="language-javascript">router.post(&quot;/api/image-generation&quot;, async (ctx) =&gt; {
    try {
        const { prompt, width, height, temperature } = ctx.request.body;

        if (!prompt) {
            ctx.status = 400;
            ctx.body = { success: false, message: &quot;缺少必要参数: prompt&quot; };
            return;
        }

        const { APP_ID, API_KEY, API_SECRET, IMAGE_API_URL } = API_CONFIG;
        const authUrl = assembleAuthUrl(IMAGE_API_URL, &quot;POST&quot;, API_KEY, API_SECRET);

        const requestData = {
            header: {
                app_id: APP_ID,
                uid: `user_${Date.now()}`, // 用户标识，可自定义
            },
            parameter: {
                chat: {
                    domain: &quot;general&quot;, // 图片场景，general 通用场景
                    width: width || 512,
                    height: height || 512,
                    temperature: temperature || 0.5, // 随机度，越大越随机
                    max_tokens: 4096, // 通常不需要这么大，但与文档保持一致
                },
            },
            payload: {
                message: {
                    text: [{ role: &quot;user&quot;, content: prompt }],
                },
            },
        };

        const response = await axios.post(authUrl, requestData, {
            headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },
        });

        ctx.body = response.data;
    } catch (error) {
        console.error(&quot;图片生成API代理错误:&quot;, error.response ? error.response.data : error.message);
        ctx.status = error.response?.status || 500;
        ctx.body = {
            success: false,
            message: &quot;图片生成API请求失败&quot;,
            error: error.response?.data || error.message || &quot;服务器内部错误&quot;,
        };
    }
});
</code></pre>
<p><strong>5. 文本对话代理路由 (<code>/api/chat</code>)</strong><br>
然后，我们配置文本对话的代理路由。这个路由将使用 <code>API_PASSWORD</code> 进行 Bearer Token 认证。</p>
<pre><code class="language-javascript">router.post(&quot;/api/chat&quot;, async (ctx) =&gt; {
    try {
        const { message, history } = ctx.request.body; // history 用于支持多轮对话

        if (!message) {
            ctx.status = 400;
            ctx.body = { success: false, message: &quot;缺少必要参数: message&quot; };
            return;
        }

        const { API_PASSWORD, CHAT_API_URL } = API_CONFIG; // APP_ID 用于请求体

        // 构建符合讯飞星火非流式API文档的请求体
        const requestData = {
           max_tokens: 4096,
            top_k: 6,
            temperature: 1,
            messages: [
                {
                    role: &quot;user&quot;,
                    content: message,
                },
                ...(history || []),
            ],
            model: &quot;lite&quot;,
        };
    
        const response = await axios.post(CHAT_API_URL, requestData, {
            headers: {
                &quot;Content-Type&quot;: &quot;application/json&quot;,
                &quot;Authorization&quot;: &quot;Bearer &quot; + API_PASSWORD, // 使用 APIPassword 作为 Bearer Token
            },
        });
        ctx.body = response.data;
        } catch (error) {
            console.error(&quot;对话API请求失败:&quot;, error.message);
            ctx.status = 500;
            ctx.body = {
                success: false,
                message: &quot;对话API请求失败&quot;,
                error: error.message,
            };
        }
});
</code></pre>
<p><strong>6. 注册路由并启动服务器</strong><br>
最后，在 <code>app.js</code> 中注册路由并启动 Koa 服务器：</p>
<pre><code class="language-javascript">// 注册路由
app.use(router.routes()).use(router.allowedMethods());

// 添加一个简单的状态检查路由
router.get(&quot;/api/status&quot;, (ctx) =&gt; {
    ctx.body = { success: true, message: &quot;讯飞星火API代理服务器运行中&quot; };
});

// 启动服务器
app.listen(PORT, () =&gt; {
    console.log(`讯飞星火API代理服务器已启动，监听端口: ${PORT}`);
    console.log(`服务器状态检查: http://localhost:${PORT}/api/status`);
    console.log(`图片生成API代理: POST http://localhost:${PORT}/api/image-generation`);
    console.log(`对话API代理: POST http://localhost:${PORT}/api/chat`);
});
</code></pre>
<p>现在，你可以通过 <code>npm run dev</code> (如果安装了 nodemon) 或 <code>npm start</code> 来启动后端代理服务。</p>
<h2 id="前端-api-服务封装">前端 API 服务封装</h2>
<p>为了使前端代码更整洁，我们将 API 调用封装成服务模块。在 Vue 项目的 <code>src</code> 目录下创建一个 <code>services</code> 文件夹。</p>
<p><strong>1. 图片生成服务 (<code>ImageGenerationService.js</code>)</strong></p>
<pre><code class="language-javascript">/**
 * 讯飞星火图片生成API服务
 * 通过Koa2代理服务器调用讯飞API，解决跨域问题。
 * API密钥等敏感信息已配置在后端服务器中。
 * 参考文档: https://www.xfyun.cn/doc/spark/ImageGeneration.html
 */
import axios from &quot;axios&quot;;

const API_CONFIG = {
    PROXY_URL: &quot;http://localhost:3000/api/image-generation&quot;, // 后端代理地址
};

/**
 * 通过代理服务器请求生成图片
 * @param {string} prompt - 图片描述
 * @param {number} [width=512] - 图片宽度
 * @param {number} [height=512] - 图片高度
 * @param {number} [temperature=0.5] - 随机度
 * @returns {Promise&lt;string&gt;} - 返回生成的图片Base64数据或URL
 */
async function generateImage(prompt, width = 512, height = 512, temperature = 0.5) {
    try {
        const requestData = { prompt, width, height, temperature };
        const response = await axios.post(API_CONFIG.PROXY_URL, requestData, {
            headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },
        });

        if (
            response.data &amp;&amp;
            response.data.payload &amp;&amp;
            response.data.payload.choices &amp;&amp;
            response.data.payload.choices.text &amp;&amp;
            response.data.payload.choices.text[0] &amp;&amp;
            response.data.payload.choices.text[0].content
        ) {
            const imageData = response.data.payload.choices.text[0].content;
            // 讯飞图片生成通常返回Base64编码的图片数据，有时可能不带 &quot;data:image/png;base64,&quot; 前缀
            if (imageData.startsWith(&quot;data:image&quot;)) {
                return imageData;
            } else if (imageData.startsWith(&quot;http&quot;)) { // 虽然不常见，但以防万一返回的是URL
                return imageData;
            } else {
                // 如果是纯Base64，添加标准前缀
                return `data:image/png;base64,${imageData}`;
            }
        } else {
            console.error(&quot;图片API响应格式不符合预期:&quot;, response.data);
            throw new Error(response.data.message || &quot;图片API响应格式不符合预期&quot;);
        }
    } catch (error) {
        console.error(&quot;图片生成失败:&quot;, error.response ? error.response.data : error);
        throw error.response ? new Error(error.response.data.message || '图片生成服务调用失败') : error;
    }
}

export default {
    generateImage,
};
</code></pre>
<p><strong>2. 文本对话服务 (<code>ChatService.js</code>)</strong></p>
<pre><code class="language-javascript">/**
 * 讯飞星火Lite对话API服务
 * 通过Koa2代理服务器调用讯飞API，解决跨域问题。
 * API密钥等敏感信息已配置在后端服务器中。
 * 参考文档: https://www.xfyun.cn/doc/spark/HTTP%E8%B0%83%E7%94%A8%E6%96%87%E6%A1%A3.html (非流式)
 */
import axios from &quot;axios&quot;;

const API_CONFIG = {
    PROXY_URL: &quot;http://localhost:3000/api/chat&quot;, // 后端代理地址
};

/**
 * 通过代理服务器发送对话请求
 * @param {string} message - 用户消息内容
 * @param {Array&lt;{role: string, content: string}&gt;} [history=[]] - 历史对话记录
 * @returns {Promise&lt;string&gt;} - 返回AI的回复文本
 */
async function sendMessage(message, history = []) {
    try {
        // 构建请求体 - 只发送必要的对话参数
        const requestData = {
            message,
            history,
        };

        // 发送请求到代理服务器
        const response = await axios.post(API_CONFIG.PROXY_URL, requestData, {
            headers: {
                &quot;Content-Type&quot;: &quot;application/json&quot;,
            },
        });

        // 处理响应
        if (response.data.choices[0].message.content) {
            // 从响应中提取AI回复
            return response.data.choices[0].message.content;
        } else {
            console.error(&quot;API响应格式:&quot;, response.data);
            throw new Error(&quot;API响应格式不符合预期&quot;);
        }
    } catch (error) {
        console.error(&quot;对话请求失败:&quot;, error);
        throw error;
    }
}
export default {
    sendMessage,
};
</code></pre>
<h2 id="vue-构建-ui-界面">Vue 构建 UI 界面</h2>
<p>接下来，我们使用 Vue2 构建一个简单的用户界面，允许用户进行文本对话或生成图片。我们将创建一个主组件 <code>App.vue</code>。</p>
<p><strong>核心思路：</strong></p>
<ul>
<li><strong>模式切换：</strong> 顶部提供按钮，用于在“文本对话”和“图片生成”模式间切换。</li>
<li><strong>消息展示：</strong> 将用户输入和 AI 回复（包括生成的图片）都存储在一个 <code>messages</code> 数组中，并统一渲染到聊天窗口。</li>
<li><strong>上下文保持：</strong> 对于文本对话，维护一个 <code>chatHistory</code> 数组，用于向 API 传递上下文信息，实现多轮对话。</li>
</ul>
<p><strong>1. 数据初始化 (<code>data</code>)</strong><br>
在 <code>App.vue</code> 的 <code>&lt;script&gt;</code> 部分，我们首先定义组件的 <code>data</code>：</p>
<pre><code class="language-javascript">// &lt;script&gt;
// ... (imports)
export default {
    name: &quot;App&quot;,
    data() {
        return {
            userInput: &quot;&quot;, // 用户输入的内容
            messages: [    // 对话/图片消息列表
                {
                    role: &quot;assistant&quot;, // 角色：assistant (AI) 或 user (用户)
                    content: &quot;您好！我是星火AI助手，可以进行文本对话或生成图片。请选择您需要的模式。&quot;,
                },
            ],
            loading: false, // 是否正在加载 (API请求中)
            imageSize: &quot;512x512&quot;, // 默认图片尺寸
            mode: &quot;chat&quot;, // 当前模式: 'chat' (对话) 或 'image' (图片生成)
            chatHistory: [], // 用于API的对话历史记录 (仅文本对话模式)
        };
    },
    // ... (methods, mounted, etc.)
}
// &lt;/script&gt;
</code></pre>
<p>初始状态下，<code>mode</code> 为对话模式 (<code>'chat'</code>)，<code>loading</code> 为 <code>false</code> (未加载)，并有一条欢迎消息。</p>
<p><strong>2. UI 模板 (<code>&lt;template&gt;</code>)</strong><br>
下面是 <code>App.vue</code> 的模板部分，构建了聊天界面的基本布局：</p>
<pre><code class="language-vue">&lt;template&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;div class=&quot;chat-container&quot;&gt;
            &lt;div class=&quot;chat-header&quot;&gt;
                &lt;h1&gt;
                    {{ mode === &quot;chat&quot; ? &quot;星火AI对话&quot; : &quot;星火AI图片生成&quot; }}
                &lt;/h1&gt;
                &lt;div class=&quot;mode-toggle&quot;&gt;
                    &lt;button
                        @click=&quot;switchMode('chat')&quot;
                        :class=&quot;['mode-btn', mode === 'chat' ? 'active' : '']&quot;
                        title=&quot;文本对话模式&quot;
                    &gt;
                        &lt;i class=&quot;mode-icon chat-icon&quot;&gt;💬&lt;/i&gt;
                    &lt;/button&gt;
                    &lt;button
                        @click=&quot;switchMode('image')&quot;
                        :class=&quot;['mode-btn', mode === 'image' ? 'active' : '']&quot;
                        title=&quot;图片生成模式&quot;
                    &gt;
                        &lt;i class=&quot;mode-icon image-icon&quot;&gt;🖼️&lt;/i&gt;
                    &lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;chat-messages&quot; ref=&quot;chatMessages&quot;&gt;
                &lt;div
                    v-for=&quot;(message, index) in messages&quot;
                    :key=&quot;index&quot;
                    :class=&quot;['message', message.role]&quot;
                &gt;
                    &lt;div class=&quot;message-content&quot; v-if=&quot;message.content&quot; v-html=&quot;formatMessageContent(message.content)&quot;&gt;&lt;/div&gt;
                    &lt;div class=&quot;message-image&quot; v-if=&quot;message.imageUrl&quot;&gt;
                        &lt;img :src=&quot;message.imageUrl&quot; alt=&quot;生成的图片&quot; /&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;message-error&quot; v-if=&quot;message.error&quot;&gt;
                        &lt;p&gt;&lt;strong&gt;错误：&lt;/strong&gt;{{ message.error }}&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;image-options&quot; v-if=&quot;mode === 'image'&quot;&gt;
                &lt;div class=&quot;option-group&quot;&gt;
                    &lt;label for=&quot;imageSizeSelect&quot;&gt;图片尺寸:&lt;/label&gt;
                    &lt;select id=&quot;imageSizeSelect&quot; v-model=&quot;imageSize&quot;&gt;
                        &lt;option value=&quot;512x512&quot;&gt;512 x 512&lt;/option&gt;
                        &lt;option value=&quot;768x768&quot;&gt;768 x 768&lt;/option&gt;
                        &lt;option value=&quot;1024x1024&quot;&gt;1024 x 1024&lt;/option&gt;
                         &lt;option value=&quot;1024x768&quot;&gt;1024 x 768 (风景)&lt;/option&gt;
                        &lt;option value=&quot;768x1024&quot;&gt;768 x 1024 (人像)&lt;/option&gt;
                    &lt;/select&gt;
                &lt;/div&gt;
            &lt;/div&gt;

            &lt;div class=&quot;chat-input&quot;&gt;
                &lt;input
                    type=&quot;text&quot;
                    v-model=&quot;userInput&quot;
                    @keyup.enter=&quot;handleSubmit&quot;
                    :placeholder=&quot;
                        mode === 'chat'
                            ? '请输入您的问题...'
                            : '请描述您想要生成的图片...'
                    &quot;
                    :disabled=&quot;loading&quot;
                    ref=&quot;mainInput&quot;
                /&gt;
                &lt;button
                    class=&quot;submit-btn&quot;
                    @click=&quot;handleSubmit&quot;
                    :disabled=&quot;loading || !userInput.trim()&quot;
                &gt;
                    {{
                        loading
                            ? &quot;处理中...&quot;
                            : mode === &quot;chat&quot;
                            ? &quot;发送&quot;
                            : &quot;生成图片&quot;
                    }}
                &lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p><strong>3. 核心逻辑 (<code>&lt;script&gt;</code>)</strong><br>
包含了模式切换、消息发送、图片生成等核心方法。</p>
<pre><code class="language-javascript">// App.vue
import ImageGenerationService from &quot;./services/ImageGenerationService&quot;;
import ChatService from &quot;./services/ChatService&quot;;

export default {
    name: &quot;App&quot;,
    data() {
        return {
            userInput: &quot;&quot;,
            messages: [
                {
                    role: &quot;assistant&quot;,
                    content: &quot;您好！我是星火AI助手，可以进行文本对话或生成图片。请选择您需要的模式。&quot;,
                },
            ],
            loading: false,
            imageSize: &quot;512x512&quot;, // 默认图片尺寸
            mode: &quot;chat&quot;, // 默认为对话模式
            chatHistory: [], // 用于API的对话历史记录
        };
    },
    methods: {
        formatMessageContent(content) {
            // 将换行符 \n 替换为 &lt;br&gt; 以便在HTML中正确显示换行
            return content.replace(/\n/g, '&lt;br&gt;');
        },
        // 切换模式（对话/图片生成）
        switchMode(newMode) {
            if (this.mode !== newMode &amp;&amp; !this.loading) {
                this.mode = newMode;
                this.userInput = &quot;&quot;; // 清空输入框
                this.messages.push({
                    role: &quot;assistant&quot;,
                    content: newMode === &quot;chat&quot;
                            ? &quot;已切换到文本对话模式。您可以向我提问任何问题。&quot;
                            : &quot;已切换到图片生成模式。请描述您想要生成的图片。&quot;,
                });
                if (newMode === 'chat') {
                    // 如果切换到聊天模式，可以考虑是否清空 chatHistory，或根据产品逻辑决定
                    // this.chatHistory = [];
                }
                this.$nextTick(() =&gt; this.$refs.mainInput.focus());
                this.scrollToBottom();
            }
        },

        // 处理用户输入提交
        handleSubmit() {
            if (!this.userInput.trim() || this.loading) return;

            if (this.mode === &quot;chat&quot;) {
                this.sendChatMessage();
            } else {
                this.generateImage();
            }
        },

        // 发送对话消息
        async sendChatMessage() {
            const userMessageContent = this.userInput;
            this.messages.push({ role: &quot;user&quot;, content: userMessageContent });
            this.chatHistory.push({ role: &quot;user&quot;, content: userMessageContent }); // 更新API对话历史

            this.userInput = &quot;&quot;;
            this.loading = true;
            this.scrollToBottom(); // 用户消息发出后滚动

            const thinkingMessageIndex = this.messages.length; // 记录思考消息的索引
            this.messages.push({ role: &quot;assistant&quot;, content: &quot;思考中...&quot; });
            this.scrollToBottom(); // 思考消息发出后滚动

            try {
                // 注意：传递给API的history不应包含当前正在处理的用户消息，而是它之前的记录
                // 但讯飞的文档似乎倾向于将当前用户消息也加入到 messages 列表中
                // 为保险起见，我们传递包含当前用户问题的 history
                const currentHistoryForAPI = [...this.chatHistory];

                const response = await ChatService.sendMessage(userMessageContent, currentHistoryForAPI.slice(0, -1)); // 传递最近一次用户输入之前的历史

                this.messages.splice(thinkingMessageIndex, 1, { role: &quot;assistant&quot;, content: response }); // 替换思考消息
                this.chatHistory.push({ role: &quot;assistant&quot;, content: response }); // 更新API对话历史

            } catch (error) {
                console.error(&quot;对话请求出错:&quot;, error);
                this.messages.splice(thinkingMessageIndex, 1, {
                    role: &quot;assistant&quot;,
                    content: `抱歉，对话过程中发生错误: ${error.message}`,
                    error: error.message,
                });
            } finally {
                this.loading = false;
                this.$nextTick(() =&gt; this.$refs.mainInput.focus());
                this.scrollToBottom();
            }
        },

        // 生成图片
        async generateImage() {
            const prompt = this.userInput;
            this.messages.push({ role: &quot;user&quot;, content: `图片描述：${prompt}` });

            this.userInput = &quot;&quot;;
            this.loading = true;
            this.scrollToBottom();

            const generatingMessageIndex = this.messages.length;
            this.messages.push({ role: &quot;assistant&quot;, content: &quot;正在生成您描述的图片，请稍候...&quot; });
            this.scrollToBottom();

            try {
                const [widthStr, heightStr] = this.imageSize.split(&quot;x&quot;);
                const width = parseInt(widthStr, 10);
                const height = parseInt(heightStr, 10);

                const imageUrl = await ImageGenerationService.generateImage(prompt, width, height, 0.5);

                this.messages.splice(generatingMessageIndex, 1, {
                    role: &quot;assistant&quot;,
                    content: `已根据您的描述&quot;${prompt}&quot;生成图片：`,
                    imageUrl: imageUrl,
                });

            } catch (error) {
                console.error(&quot;图片生成出错:&quot;, error);
                 this.messages.splice(generatingMessageIndex, 1, {
                    role: &quot;assistant&quot;,
                    content: `抱歉，图片生成过程中发生错误: ${error.message}`,
                    error: error.message,
                });
            } finally {
                this.loading = false;
                this.$nextTick(() =&gt; this.$refs.mainInput.focus());
                this.scrollToBottom();
            }
        },

        // 滚动到最新消息
        scrollToBottom() {
            this.$nextTick(() =&gt; {
                const chatMessagesEl = this.$refs.chatMessages;
                if (chatMessagesEl) {
                    chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
                }
            });
        },
    },
    mounted() {
        this.$nextTick(() =&gt; {
            if (this.$refs.mainInput) {
                this.$refs.mainInput.focus();
            }
        });
    },
};
&lt;/script&gt;
</code></pre>
<p><strong>4. 样式 (<code>&lt;style&gt;</code>)</strong><br>
为组件添加一些美化样式：</p>
<pre><code class="language-css">/* App.vue */
&lt;style&gt;
#app {
    font-family: Avenir, Helvetica, Arial, sans-serif;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    color: #2c3e50;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: #f0f2f5; /* 更柔和的背景色 */
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

.chat-container {
    width: 90%;
    max-width: 800px; /* 限制最大宽度 */
    height: 90vh; /* 调整高度 */
    max-height: 700px; /* 增加最大高度限制 */
    display: flex;
    flex-direction: column;
    border-radius: 12px; /* 更圆润的边角 */
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1); /* 更明显的阴影 */
    background-color: white;
    overflow: hidden; /* 确保子元素不会溢出圆角 */
}

.chat-header {
    padding: 16px 24px; /* 调整内边距 */
    background-color: #1890ff; /* 主题色，例如 Ant Design 蓝 */
    color: white;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #e8e8e8; /* 底部边框 */
}

.chat-header h1 {
    margin: 0;
    font-size: 1.4rem; /* 调整标题大小 */
    font-weight: 500;
}

.mode-toggle {
    display: flex;
    gap: 12px; /* 按钮间距 */
}

.mode-btn {
    background-color: rgba(255, 255, 255, 0.15);
    border: 1px solid rgba(255, 255, 255, 0.3); /* 添加边框 */
    border-radius: 8px; /* 圆角按钮 */
    width: 40px; /* 调整大小 */
    height: 40px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    transition: all 0.3s ease;
    color: white; /* 图标颜色 */
}

.mode-btn:hover {
    background-color: rgba(255, 255, 255, 0.3);
}

.mode-btn.active {
    background-color: rgba(255, 255, 255, 0.4);
    box-shadow: 0 0 0 2px white, 0 0 8px rgba(255, 255, 255, 0.5); /* 激活状态更明显 */
}

.mode-icon {
    font-size: 20px; /* 图标大小 */
    font-style: normal;
}

.chat-messages {
    flex: 1;
    padding: 20px 24px; /* 内边距 */
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 18px; /* 消息间距 */
    background-color: #f9f9f9; /* 消息区域背景色 */
}

.message {
    max-width: 75%; /* 消息最大宽度 */
    padding: 12px 18px; /* 消息内边距 */
    border-radius: 18px; /* 消息气泡圆角 */
    word-break: break-word;
    line-height: 1.6;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.message.user {
    align-self: flex-end;
    background-color: #1890ff; /* 用户消息颜色 */
    color: white;
    border-bottom-right-radius: 6px; /* 调整特定角，使其更像聊天气泡 */
}

.message.assistant {
    align-self: flex-start;
    background-color: #e9e9eb; /* AI消息背景色 */
    color: #333;
    border-bottom-left-radius: 6px;
}
.message-error {
    color: #ff4d4f; /* 错误信息颜色 */
    background-color: #fff1f0;
    border: 1px solid #ffccc7;
    padding: 8px 12px;
    border-radius: 4px;
    margin-top: 5px;
}

.message-content {
    white-space: pre-wrap; /* 保留换行符和空格 */
}

.message-image {
    margin-top: 8px; /* 图片与文本间距 */
    border-radius: 10px; /* 图片圆角 */
    overflow: hidden;
    max-width: 100%;
    /* box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08); */
}

.message-image img {
    max-width: 100%; /* 限制图片最大宽度 */
    max-height: 300px; /* 限制图片最大高度 */
    height: auto;
    display: block;
    border-radius: 10px; /* 确保图片本身也有圆角 */
}

.image-options {
    padding: 12px 24px; /* 内边距 */
    background-color: #ffffff; /* 选项区域背景 */
    border-top: 1px solid #e8e8e8; /* 顶部边框 */
    display: flex;
    align-items: center; /* 垂直居中 */
}

.option-group {
    display: flex;
    align-items: center;
}

.option-group label {
    margin-right: 10px; /* 标签与选择框间距 */
    font-size: 0.9rem;
    color: #555;
}

.option-group select {
    padding: 8px 12px; /* 选择框内边距 */
    border: 1px solid #d9d9d9; /* 边框颜色 */
    border-radius: 6px; /* 圆角 */
    background-color: white;
    font-size: 0.9rem;
    outline: none;
    transition: border-color 0.3s;
}
.option-group select:hover {
    border-color: #1890ff;
}


.chat-input {
    display: flex;
    padding: 15px 24px; /* 内边距 */
    border-top: 1px solid #e8e8e8; /* 顶部边框 */
    background-color: #ffffff; /* 输入区域背景 */
}

.chat-input input {
    flex: 1;
    padding: 10px 15px; /* 输入框内边距 */
    border: 1px solid #d9d9d9;
    border-radius: 20px; /* 圆角输入框 */
    outline: none;
    font-size: 1rem;
    transition: border-color 0.3s, box-shadow 0.3s;
}
.chat-input input:focus {
    border-color: #1890ff;
    box-shadow: 0 0 0 2px rgba(24, 144, 255, 0.2);
}

.chat-input .submit-btn {
    margin-left: 12px; /* 按钮与输入框间距 */
    padding: 10px 20px;
    background-color: #1890ff;
    color: white;
    border: none;
    border-radius: 20px; /* 圆角按钮 */
    cursor: pointer;
    font-size: 1rem;
    transition: background-color 0.3s, opacity 0.3s;
    display: flex;
    align-items: center;
    justify-content: center;
}

.chat-input .submit-btn:hover {
    background-color: #40a9ff; /* 悬停颜色 */
}

.chat-input .submit-btn:disabled {
    background-color: #b3d1f0; /* 禁用颜色 */
    opacity: 0.7;
    cursor: not-allowed;
}

/* 响应式调整 */
@media (max-width: 768px) {
    .chat-container {
        width: 100%;
        height: 100vh;
        max-height: none;
        border-radius: 0;
    }

    .message {
        max-width: 85%;
    }

    .image-options {
        flex-direction: column;
        align-items: flex-start; /* 左对齐 */
        gap: 10px;
    }
    .chat-header h1 {
        font-size: 1.2rem;
    }
    .mode-btn {
        width: 36px;
        height: 36px;
    }
    .mode-icon {
        font-size: 18px;
    }
}
&lt;/style&gt;
</code></pre>
<p>将以上 <code>&lt;template&gt;</code>, <code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code> 部分整合到一个 <code>App.vue</code> 文件中，并在你的 Vue 项目中正确引入和使用它（通常是替换 <code>main.js</code> 中默认的 <code>App.vue</code>）。确保你的 Vue 项目已经安装了 <code>axios</code> (<code>npm install axios</code>)。</p>
<h2 id="总结">总结</h2>
<p>通过以上步骤，我们成功地在 Vue2 项目中集成了讯飞星火大模型的文本对话和图片生成功能。整个过程涉及到了讯飞平台的注册配置、API 的理解、后端 Koa2 代理的搭建，以及前端 Vue 页面的构建和 API 调用。虽然讯飞的 API 文档在某些细节上（特别是 Lite 版的非流式对话接口参数结构）可能需要仔细甄别和测试，但总体而言，其免费的 Lite 版为开发者提供了一个很好的 AI 功能体验入口。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello World]]></title>
        <id>https://whitsats.github.io/post/hello-world/</id>
        <link href="https://whitsats.github.io/post/hello-world/">
        </link>
        <updated>2025-04-29T00:22:50.000Z</updated>
        <summary type="html"><![CDATA[<p><strong>哈喽，世界！好久不见，我的博客又回来啦！</strong></p>
]]></summary>
        <content type="html"><![CDATA[<p><strong>哈喽，世界！好久不见，我的博客又回来啦！</strong></p>
<!-- more -->
<p>说起来，这已经不是我第一次开博客了。大概在十年前，我还是一枚青涩的编程小白那会儿，就兴冲冲地搭建了自己的第一个博客。当时的想法其实挺简单的：</p>
<p>一来呢，是想把自己学习编程过程中踩过的坑、总结的心得都记下来。你知道的，好记性不如烂笔头嘛，写下来方便自己以后查阅，也算是一种网络备份，省得哪天电脑坏了资料全丢。</p>
<p>二来呢，也是希望能通过这个小小的窗口，认识一些同样在学习或者已经在大厂搬砖的朋友。大家可以交流交流技术，分享分享经验，或者哪怕只是在网上互相打个气，感觉也会很不一样。那会儿真是热情满满啊！</p>
<p>可是后来嘛，人总会长大，事情也越来越多。不知道从什么时候开始，当初那股爱分享的热情好像慢慢退潮了。可能是觉得自己懂得还不够多，不好意思在网上“班门弄斧”；也可能是各种笔记软件、效率工具用得越来越顺手，觉得随时随地在本地记录更方便、更私密一些。总之，写着写着就更多变成了自己的“私房笔记”，博客这边自然就渐渐荒废了，草都长得老高了吧（笑）。</p>
<p>最近这段时间，不知道怎么回事，感觉工作和生活都碰到了一个坎儿，有点儿“卡壳”了。工作上，好像进入了一个平台期，每天忙忙碌碌却又觉得有点茫然，不知道下一步该往哪个方向使劲才能突破。生活上呢，也觉得有点提不起精神，日复一日，好像缺少了点新鲜感和前进的动力。</p>
<p>这种感觉挺不好受的，也让我开始反思：我是不是跑得太快，或者是在原地打转太久，忘了当初为什么出发？也许，现在是时候按下暂停键，稍微放慢脚步，等一等那个有点迷失、有点疲惫的自己了。</p>
<p>所以，兜兜转转，我又回到了这里，重新搭起了这个小小的博客空间。我希望，能像十年前那样，重新开始用文字记录下我的工作和生活。不一定非要写得多深刻、多高大上，就是记录下那些解决问题的小小成就感，工作中遇到的困惑和思考，生活里的那些温暖瞬间，或者是偶尔的emo时刻。</p>
<p>我把它看作是一个“重启”按钮，希望能通过这种持续的记录和梳理，帮自己理清思路，找到新的方向感。更重要的，是希望以这样一种开放和记录的方式，督促自己保持学习、保持思考，以一个全新的、更积极的状态，去迎接那个可能就在转角等着我的、全新的自己。</p>
<p>“Hello World”—— 这句每个程序员入门时在屏幕上敲下的第一行代码，简单，却代表着一个新世界的开启。现在，我把它写在这里，作为我博客重启的第一句话。对我来说，它不仅仅是一句程序员都懂的问候，更像是一种宣告：嘿，世界，我要用一种全新的、像初学者一样充满好奇和探索欲的心态，重新出发啦！</p>
<p>希望这一次，能坚持得久一点，走得更踏实一点。你好，新开始！</p>
]]></content>
    </entry>
</feed>